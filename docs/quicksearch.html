<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"lib_getRedisCache.js.html":{"id":"lib_getRedisCache.js.html","title":"Source: lib/getRedisCache.js","body":" DocStrap Modules ApiControllerAPPBlastCommand Global bluebirdfslog4jsPromiseredis Source: lib/getRedisCache.js /** * Created by Shawn Liu on 17/4/19. */ const bluebird = require('bluebird'); const redis = require('redis'); bluebird.promisifyAll(redis.RedisClient.prototype); bluebird.promisifyAll(redis.Multi.prototype); const sha1 = require('crypto-sha1'); const getRedis = require('./getRedis'); const RedisCache = function (client, options) {// arrow function can not be used as constructor this.client = client || redis.createClient(options); this.defaultOptions = { expire: 600 // 10 minutes } this.options = Object.assign({}, this.defaultOptions, options); } const isJSON = (string) =&gt; { try { if (typeof string === 'string') { JSON.parse(string); } else { JSON.stringify(string); } return true; } catch (e) { return false; } } RedisCache.prototype.setItem = async function (key, value, expires) { const self = this; if (key &amp;&amp; value) { const result = await self.client.setAsync(`data_cache_${sha1(key)}`, isJSON(value) ? JSON.stringify(value) : value, 'EX', expires || self.options.expire); return result; } console.error('both key and value are required when save cache'); return Promise.resolve(); } RedisCache.prototype.getItem = async function (key) { const self = this; const hashKey = `data_cache_${sha1(key)}`; const result = await self.client.getAsync(hashKey); return result &amp;&amp; isJSON(result) ? JSON.parse(result) : result; } RedisCache.prototype.removeItem = async function (key) { const self = this; return self.client.delAsync(`data_cache_${sha1(key)}`); } // module.exports = RedisCache; module.exports = (options) =&gt; { return new RedisCache(getRedis(), options); } × Search results Close "},"lib_formatOut0.js.html":{"id":"lib_formatOut0.js.html","title":"Source: lib/formatOut0.js","body":" DocStrap Modules ApiControllerAPPBlastCommand Global bluebirdfslog4jsPromiseredis Source: lib/formatOut0.js /** * Created by shawn-liu on 17/10/24. */ const fs = require('fs'); const path = require('path'); const readline = require('readline'); const Promise = require('bluebird'); const Sequence = function (fastaHeader) { this.fastaHeader = fastaHeader.replace('&gt;', '').replace(/\\r\\n/g, '~').trim(); this.subjects = []; this.attributes = []; this._fns = { getAttrValue(str) { const json = {key: '', value: ''}; const array = str.split(/=|:/); json.key = array[0].trim(); const valueS = array[1]; const splitKeys = ['bits', ':', '(']; for (let i = 0; i &lt; splitKeys.length; i++) { if (valueS.indexOf(splitKeys[i]) !== -1) { json.value = valueS.split(splitKeys[i])[0].trim(); break; } } if (!json.value) { json.value = valueS.trim(); } return json; } } } Sequence.prototype.setLength = function (len) { this.length = len; } Sequence.prototype.addAttribute = function (attr) { if (attr.trim()) this.attributes.push(attr.trim()); } Sequence.prototype.addQuerySubject = function (lineArray) { this.subjects.push(lineArray); } Sequence.prototype.calculate = function () { const json = { hits: [] }; const self = this; json.fastaHeader = this.fastaHeader; self.attributes.forEach(line =&gt; { line.split(',').forEach(pair =&gt; { const temp = self._fns.getAttrValue(pair); // if (temp.key === 'Score') { // temp.value = parseInt(temp.value); // } else if (temp.key === 'Expect') { // temp.value = parseFloat(temp.value).toFixed(1); // } json[temp.key] = temp.value; }); }); self.subjects.forEach(subQ =&gt; { const json1 = {}; const qA = subQ[0].split(' ').filter(t =&gt; t); json1.queryStart = parseInt(qA[1].trim()); json1.queryString = qA[2].trim(); json1.queryEnd = parseInt(qA[3].trim()); const hit = subQ[1]; json1.matched = hit.trim(); const sA = subQ[2].split(' ').filter(t =&gt; t); json1.subjectStart = parseInt(sA[1].trim()); json1.subjectString = sA[2]; json1.subjectEnd = parseInt(sA[3]); json.hits.push(json1); }); return json; } const read = async (filePath) =&gt; { return new Promise((resolve, reject) =&gt; { const resultList = []; const linereader = readline.createInterface({ input: fs.createReadStream(filePath) }); let sequenceCount = 0; let subjectStart = false; let sequenceObj = null; let subjectQueryArray = []; let fastaHeader = ''; let beginParseHeader = false; let foundFirstElement = false; linereader.on('line', originalLine =&gt; { const line = originalLine.trim(); if (!line) { return; } if (line.indexOf('AAE38413') !== -1) { console.log(line); } foundFirstElement = foundFirstElement || line.charAt(0) === '&gt;'; if (foundFirstElement) { // when find the first &gt; , begin to parse the data beginParseHeader = beginParseHeader || line.charAt(0) === '&gt;'; if (line.charAt(0) === '&gt;' &amp;&amp; sequenceCount &gt; 0) { //如果开始解析下一个Sequence， 并且 Query-Subject 数组不为空， 要先加进去，否则当 只有一对 Query-Subject 的时候会被忽略掉 if (subjectQueryArray.length) { sequenceObj.addQuerySubject(subjectQueryArray); subjectQueryArray = []; } subjectStart = false; resultList.push(sequenceObj.calculate()); } if (beginParseHeader &amp;&amp; !line.startsWith('Length')) { if (fastaHeader) { fastaHeader += '~' + line; } else { fastaHeader += line; } } if (line.startsWith('Length')) { if (fastaHeader.indexOf('AAE56966') !== -1) { console.log(1) } beginParseHeader = false; // 当匹配到Length 开头的时候，说明fasta header 解析完,然后开始解析length sequenceObj = new Sequence(fastaHeader); fastaHeader = ''; sequenceCount++; sequenceObj.setLength(line.replace('Length=', '')); } else if (line.startsWith('Score') || line.startsWith('Identities')) { sequenceObj.addAttribute(line); } else { subjectStart = subjectStart || line.startsWith('Query'); if (subjectStart) { // 到找到下个Query-Subject的时候，把当前的加入到Sequence Object 里 if (line.startsWith('Query')) { if (subjectQueryArray.length) { sequenceObj.addQuerySubject(subjectQueryArray); subjectQueryArray = []; } } subjectQueryArray.push(line); } } } }); linereader.on('close', (err, data) =&gt; { if (sequenceObj) { resultList.push(sequenceObj.calculate()); } resolve(resultList); }); }); } module.exports = read; // const run = async () =&gt; { // // const txt = fs.readFileSync('../../sample/outfmt0.txt').toString(); // const filePath = path.join(__dirname, '../../sample/outfmt0.txt'); // const list = await read(filePath); // console.log(JSON.stringify(list, null, 2)); // } // // run() × Search results Close "},"lib_getLogger.js.html":{"id":"lib_getLogger.js.html","title":"Source: lib/getLogger.js","body":" DocStrap Modules ApiControllerAPPBlastCommand Global bluebirdfslog4jsPromiseredis Source: lib/getLogger.js /** * Created by shawn-liu on 17/9/29. */ const log4js = require('log4js'); module.exports = (category) =&gt; { const logger = log4js.getLogger(category); logger.level = process.env.LOG_LEVEL || 'debug'; return logger; }; × Search results Close "},"lib_Constant.js.html":{"id":"lib_Constant.js.html","title":"Source: lib/Constant.js","body":" DocStrap Modules ApiControllerAPPBlastCommand Global bluebirdfslog4jsPromiseredis Source: lib/Constant.js /** * Created by shawn-liu on 17/12/1. */ module.exports = { BlastDB: { Nucl: 'nucleotide', Prot: 'protein' }, BlastCommand: { Prot: 'blastp', Nucl: 'blastn', NuclOnProt: 'blastx', ProtOnNucl: 'tblaxn' }, SequenceType: { DNA: 'dna', Protein: 'protein' } }; × Search results Close "},"api_api.controller.js.html":{"id":"api_api.controller.js.html","title":"Source: api/api.controller.js","body":" DocStrap Modules ApiControllerAPPBlastCommand Global bluebirdfslog4jsPromiseredis Source: api/api.controller.js /** * Created by shawn-liu on 17/9/22. * @module ApiController * @requires BlastCommand * @author Liu Jianwei */ const blast = require('../lib/blastjs'); const listDB = require('../lib/listDB'); const logger = require('../lib/getLogger')('api.controller.js'); const bionode = require('bionode-seq'); const filterRequests = require('../lib/filterResults'); const Constant = require('../lib/Constant'); /** * @summary list all blast database * @description detect the database type by checking its file suffix * @param req * @param res * @returns {Promise.&lt;void&gt;} */ exports.getDBs = async (req, res) =&gt; { try { const dbs = await listDB(); res.json(dbs); } catch (err) { logger.error(err); res.statusCode = 500; res.send(err.message); } }; /** * * @param dbs * @param command * @param query * @param {object}requestQuery * @param {string=} requestQuery.noCache * @param {string=} requestQuery.limit * @param {string=} requestQuery.outfmt * @param {string=} requestQuery.similarity * @returns {Promise.&lt;Array&gt;} * @private */ const _execQuery = async (dbs, command, query, requestQuery) =&gt; { const dbCount = dbs.length; let results = []; let error = null; for (let i = 0; i &lt; dbCount; i++) { try { const temp = await blast[command](dbs[i], query, requestQuery.limit, requestQuery.noCache, requestQuery.outfmt); if (Array.isArray(temp)) { Array.prototype.push.apply(results, temp); } else { results.push(temp); } } catch (err) { error = err; logger.error(err); } } if (results.length === 0 &amp;&amp; error) { throw error; } if (requestQuery.similarity) { results = filterRequests.bySimilarity(results, parseFloat(requestQuery.similarity)); } return results; }; const _processRequest = async (sequence, queryType) =&gt; { if (!sequence) { throw new Error('query can not be empty'); } const sequenceType = bionode.checkType(sequence); if (sequenceType !== Constant.SequenceType.Protein &amp;&amp; sequenceType !== Constant.SequenceType.DNA) { throw new Error('the query sequence must be protein or dna'); } const dbs = await listDB(); if (!dbs || dbs.length === 0) { throw new Error('there is no database files'); } const dbType = sequenceType === 'protein' ? 'protein' : 'nucleotide'; const targetDbs = dbs[dbType]; if (!targetDbs || !targetDbs.length) { throw new Error(`There is no ${dbType} database`); } const blastCommand = (() =&gt; { let command; switch (queryType) { case Constant.BlastCommand.Prot: { command = sequenceType === Constant.SequenceType.Protein ? Constant.BlastCommand.Prot : Constant.BlastCommand.NuclOnProt; break; } case Constant.BlastCommand.Nucl: { command = sequenceType === Constant.SequenceType.Protein ? Constant.BlastCommand.ProtOnNucl : Constant.BlastCommand.Nucl; break; } default: { throw new Error(`Unsupported queryType: ${queryType}`); } } return command; })(); return { sequenceType, targetDbs, blastCommand, sequence }; }; /** * @summary query on protein database * @description first will get all protein database and exec query on each db , and them combine the results * @param req * @param {string}req.body.sequence should be protein or dna sequence * @param res * @see {@link module:BlastCommand.blastP|Query Protein} Or {@link module:BlastCommand.blastX|Query Nucleotide} * @returns {Promise.&lt;void&gt;} */ exports.queryProtein = async (req, res) =&gt; { try { const {targetDbs, sequence, queryCommand, sequenceType} = _processRequest(req.body.sequence, Constant.BlastCommand.Prot); logger.info(`query ${sequenceType} from protein dbs: ${targetDbs}`); const results = await _execQuery(targetDbs, queryCommand, sequence, req.query); res.json({ success: true, data: results }); } catch (err) { res.statusCode = 500; res.json({ success: false, message: err.message || 'failed to query from blast' }); } }; /** * @summary query nucleotide * @description first will get all nucleotide database and exec query on each db , and them combine the results * @param req * @param {string}req.body.sequence should be protein or nucleotide sequence * @param res * @see {@link module:BlastCommand.blastN|Query Nucleotide} Or {@link module:BlastCommand.tblastN|Query Protein} * @returns {Promise.&lt;void&gt;} */ exports.queryNucleotide = async (req, res) =&gt; { try { const {targetDbs, sequence, queryCommand, sequenceType} = _processRequest(req.body.sequence, Constant.BlastCommand.Prot); logger.info(`query ${sequenceType} from nucleotide dbs: ${targetDbs}`); const results = await _execQuery(targetDbs, queryCommand, sequence, req.query); res.json({ success: true, data: results }); } catch (err) { res.statusCode = 500; res.json({ success: false, message: err.message || 'failed to query from blast' }); } }; // /** // * @ignore // * @param req // * @param res // * @returns {Promise.&lt;void&gt;} // */ // exports.sequenceQuery = async (req, res) =&gt; { // const sequence = req.body.sequence; // const sequenceType = bionode.checkType(sequence); // // // } // module.exports = api; × Search results Close "},"app.js.html":{"id":"app.js.html","title":"Source: app.js","body":" DocStrap Modules ApiControllerAPPBlastCommand Global bluebirdfslog4jsPromiseredis Source: app.js /** * Created by shawn-liu on 17/9/22. * @module APP * @author Liu Jianwei */ const express = require('express'); const bodyParser = require('body-parser'); const API = require('./api/api.controller'); const logger = require('./lib/getLogger')('app.js'); const path = require('path'); const app = express(); app.use(bodyParser.json()); app.get('/dbs', API.getDBs); app.post('/blast/nucleotide', API.queryNucleotide); app.post('/blast/protein', API.queryProtein); app.post('/blast/sequence', API.sequenceQuery); app.use(express.static(path.join(__dirname, '../docs'))); /** * @summary handle the unmatched path * @description send the unmatched path to the doc page * @function Handle Unmatched Path */ app.get('*', (request, response) =&gt; { response.sendFile(path.join(__dirname, '../docs/index.html')); }); app.listen(3000, () =&gt; { logger.info('Example app listening on port 3000!'); }); × Search results Close "},"lib_blastjs.js.html":{"id":"lib_blastjs.js.html","title":"Source: lib/blastjs.js","body":" DocStrap Modules ApiControllerAPPBlastCommand Global bluebirdfslog4jsPromiseredis Source: lib/blastjs.js /** * @module BlastCommand * @author Liu Jianwei */ const Promise = require('bluebird'); const fs = Promise.promisifyAll(require('fs')); // const path = require('path'); // const xml2js = Promise.promisifyAll(require('xml2js')); const UUID = require('uuid/v4'); const CP = Promise.promisifyAll(require('child_process')); const logger = require('./getLogger')('blastjs.js'); const getRedisCache = require('./getRedisCache'); const os = require('os'); const parseFmt0 = require('./formatOut0'); let redisCache = null; /** * * @param queryCommand, blastp,blastn,tblastn,blastx * @param db * @param query * @param limit * @param noCache * @param outfmtPassed * @returns {Promise.&lt;*&gt;} * @private */ const _blaster = async (queryCommand, db, query, limit, noCache, outfmtPassed) =&gt; { let blastCommand; try { const outfmt = outfmtPassed || 0; const cacheKey = `${db}_${queryCommand}_${query}_${outfmt}`; const pathW = `/tmp/${Date.now()}.fasta`; fs.writeFileSync(pathW, query); const outFile = `/tmp/${UUID()}.out`; blastCommand = `${queryCommand} -query ${pathW} -out ${outFile} -db ${db} -outfmt ${outfmt} -num_threads ${os.cpus().length - 1}`; logger.info('RUNNING', blastCommand); if (!redisCache) { redisCache = await getRedisCache(); } let resultData = null; if (!noCache) { resultData = await redisCache.getItem(cacheKey); } if (!resultData) { await CP.execAsync(blastCommand); resultData = await fs.readFileAsync(outFile, 'utf8'); if (outfmt === 0) { resultData = await parseFmt0(outFile); } await redisCache.setItem(cacheKey, resultData, 18000);// cache 30 minutes // logger.info(resultData); logger.info('Succeed to query...'); } else { logger.warn('Using cache for command result'); } return resultData; } catch (err) { logger.error(err); throw new Error(`error when exec: ${blastCommand}:${db}:${query}`); } }; /** * Query nucleotide on specific database * @param {string}db * @param {string}query the sequence piece * @param {string=}limit * @param {boolean=}noCache * @param {string}outfmt=0 * @returns {Promise.&lt;*&gt;} */ exports.blastN = function (db, query, limit, noCache, outfmt) { return _blaster('blastn', db, query, limit, noCache, outfmt); }; /** * Query protein on specific database // * @function blastP * @param {string}db * @param {string}query the sequence piece * @param {string=}limit * @param {boolean=}noCache * @param {string}outfmt=0 * @returns {Promise.&lt;*&gt;} */ exports.blastP = function (db, query, limit, noCache, outfmt) { return _blaster('blastp', db, query, limit, noCache, outfmt); }; /** * search nucleotide on protein database * @param db * @param {string}query the sequence piece * @param {string=}limit * @param {boolean=}noCache * @param {string}outfmt=0 * @returns {Promise.&lt;*&gt;} */ exports.blastX = function (db, query, limit, noCache, outfmt) { return _blaster('blastx', db, query, limit, noCache, outfmt); }; /** * search protein on nucleotide database * @param db * @param {string}query the sequence piece * @param {string=}limit * @param {boolean=}noCache * @param {string}outfmt=0 * @returns {Promise.&lt;*&gt;} */ exports.tblastN = function (db, query, limit, noCache, outfmt) { return _blaster('tblastn', db, query, limit, noCache, outfmt); }; /** * @summary tblaspx * @description The tblastx application searches a translated nucleotide query against translated nucleotide subject sequences or a translated nucleotide database. * @param db * @param {string}query the sequence piece * @param {string=}limit * @param {boolean=}noCache * @param {string}outfmt=0 * @returns {Promise.&lt;*&gt;} */ exports.tblastX = function (db, query, limit, noCache, outfmt) { return _blaster('tblastx', db, query, limit, noCache, outfmt); }; // exports.makeDB = async (type, fileIn, outputPath, name, cb) =&gt; { // if (!type) { // return cb(new Error('no type supplied')); // } // if (!fileIn) { // return cb(new Error('no file supplied')); // } // if (!outputPath) { // return cb(new Error('no output path supplied')); // } // // const fileNamePartOne = fileIn.replace(/^.*[\\\\/]/, '');// remove directories from path // const filename = fileNamePartOne.substr(0, fileNamePartOne.lastIndexOf('.')); // remove file extensions // // let outPath = outputPath; // if (outPath.slice(-1) !== '/') { // outPath = `${outPath}/`; // add / out path is one is not supplied // } // // const fileOut = outPath + filename; // // const makeCommand = 'makeblastdb -in ' + fileIn + ' -dbtype ' + type + ' -out ' + fileOut + ' -title ' + name; // return await CP.execAsync(makeCommand); // // run(makeCommand, function (err, stdOut, stdErr) { // // return cb(err, stdOut, stdErr, fileOut); // // }); // // }; // module.exports = blast; × Search results Close "},"lib_listDB.js.html":{"id":"lib_listDB.js.html","title":"Source: lib/listDB.js","body":" DocStrap Modules ApiControllerAPPBlastCommand Global bluebirdfslog4jsPromiseredis Source: lib/listDB.js /** * Created by shawn-liu on 17/9/29. */ const Promise = require('bluebird'); const fs = Promise.promisifyAll(require('fs')); const logger = require('./getLogger')('listBlastDB.js'); const Constant = require('./Constant'); const dbRoot = process.env.BLASTDB; const cache = { add(data) { this.data = data; this.timestamp = new Date().getTime(); }, get(timeout) { const defaultTimeout = 10 * 60 * 1000;// 10 minutes; const self = this; if (!self.timestamp || !self.data) { return null; } const current = new Date().getTime(); if ((current - this.timestamp) &gt; (timeout || defaultTimeout)) { self.data = null; } return self.data; } }; module.exports = async () =&gt; { if (!dbRoot) { throw new Error('can not find blast db folder'); } logger.info(`Using BLASTDB=${process.env.BLASTDB}`); try { if (cache.get()) { return cache.get(); } const dbs = { nucleotide: {}, protein: {} }; const getDBName = str =&gt; str.replace(/(.[0-9]{2,4})/, ''); const files = await fs.readdirAsync(dbRoot); files.forEach((file) =&gt; { const pin = file.indexOf('.pin'); const nin = file.indexOf('.nin'); if (pin &gt; -1) { dbs.protein[getDBName(file.split('.pin')[0])] = 1; // dbs.protein.push(file.split('.pin')[0]); } if (nin &gt; -1) { dbs.nucleotide[getDBName(file.split('.nin')[0])] = 1; // dbs.nucleotide.push(file.split('.nin')[0]); } }); const result = {}; result[Constant.BlastDB.Nucl] = Object.keys(dbs.nucleotide); result[Constant.BlastDB.Prot] = Object.keys(dbs.protein); cache.add(result); return result; } catch (err) { logger.error(err); throw new Error('failed to list blast db'); } }; × Search results Close "},"lib_getRedis.js.html":{"id":"lib_getRedis.js.html","title":"Source: lib/getRedis.js","body":" DocStrap Modules ApiControllerAPPBlastCommand Global bluebirdfslog4jsPromiseredis Source: lib/getRedis.js /** * Created by Shawn Liu on 17/6/15. */ const redis = require('redis'); const Promise = require('bluebird'); let redisClient = null; module.exports = function () { if (!redisClient) { const redisConfig = { host: process.env.redisHost || '192.168.3.89', port: process.env.redisPort || 6379 }; redisClient = Promise.promisifyAll(redis.createClient(redisConfig)); } return redisClient; }; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" DocStrap Modules ApiControllerAPPBlastCommand Global bluebirdfslog4jsPromiseredis Global Members &lt;constant&gt; bluebird Created by Shawn Liu on 17/4/19. Created by Shawn Liu on 17/4/19. Source: lib/getRedisCache.js, line 4 &lt;constant&gt; fs Created by shawn-liu on 17/10/24. Created by shawn-liu on 17/10/24. Source: lib/formatOut0.js, line 4 &lt;constant&gt; log4js Created by shawn-liu on 17/9/29. Created by shawn-liu on 17/9/29. Source: lib/getLogger.js, line 4 &lt;constant&gt; Promise Created by shawn-liu on 17/9/29. Created by shawn-liu on 17/9/29. Source: lib/listDB.js, line 4 &lt;constant&gt; redis Created by Shawn Liu on 17/6/15. Created by Shawn Liu on 17/6/15. Source: lib/getRedis.js, line 4 × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" DocStrap Modules ApiControllerAPPBlastCommand Global bluebirdfslog4jsPromiseredis Modules × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Modules ApiControllerAPPBlastCommand Global bluebirdfslog4jsPromiseredis How to usage set the env redisHost, like redisHost=192.168.3.89 set the env BLAST for example , mount the ~/blastdb to /patsnap/blastdb and set BLASTDB=/patsnap/blastdb × Search results Close "},"module-ApiController.html":{"id":"module-ApiController.html","title":"Module: ApiController","body":" DocStrap Modules ApiControllerAPPBlastCommand Global bluebirdfslog4jsPromiseredis Module: ApiController Created by shawn-liu on 17/9/22. Author: Liu Jianwei Source: api/api.controller.js, line 1 Requires module:BlastCommand Methods &lt;static&gt; getDBs(req, res) list all blast database detect the database type by checking its file suffix Parameters: Name Type Description req res Source: api/api.controller.js, line 21 Returns: Type Promise.&lt;void&gt; &lt;static&gt; queryNucleotide(req, res) query nucleotide first will get all nucleotide database and exec query on each db , and them combine the results Parameters: Name Type Description req Properties Name Type Description body.sequence string should be protein or nucleotide sequence res Source: api/api.controller.js, line 151 See: Query Nucleotide Or Query Protein Returns: Type Promise.&lt;void&gt; &lt;static&gt; queryProtein(req, res) query on protein database first will get all protein database and exec query on each db , and them combine the results Parameters: Name Type Description req Properties Name Type Description body.sequence string should be protein or dna sequence res Source: api/api.controller.js, line 124 See: Query Protein Or Query Nucleotide Returns: Type Promise.&lt;void&gt; × Search results Close "},"module-APP.html":{"id":"module-APP.html","title":"Module: APP","body":" DocStrap Modules ApiControllerAPPBlastCommand Global bluebirdfslog4jsPromiseredis Module: APP Created by shawn-liu on 17/9/22. Author: Liu Jianwei Source: app.js, line 1 Methods &lt;inner&gt; Handle Unmatched Path() handle the unmatched path send the unmatched path to the doc page Source: app.js, line 22 × Search results Close "},"module-BlastCommand.html":{"id":"module-BlastCommand.html","title":"Module: BlastCommand","body":" DocStrap Modules ApiControllerAPPBlastCommand Global bluebirdfslog4jsPromiseredis Module: BlastCommand Author: Liu Jianwei Source: lib/blastjs.js, line 1 Methods &lt;static&gt; blastN(db, query [, limit] [, noCache], outfmt) Query nucleotide on specific database. Query nucleotide on specific database Parameters: Name Type Argument Default Description db string query string the sequence piece limit string &lt;optional&gt; noCache boolean &lt;optional&gt; outfmt string 0 Source: lib/blastjs.js, line 75 Returns: Type Promise.&lt;*&gt; &lt;static&gt; blastP(db, query [, limit] [, noCache], outfmt) Query protein on specific database // * @function blastP. Query protein on specific database // * @function blastP Parameters: Name Type Argument Default Description db string query string the sequence piece limit string &lt;optional&gt; noCache boolean &lt;optional&gt; outfmt string 0 Source: lib/blastjs.js, line 90 Returns: Type Promise.&lt;*&gt; &lt;static&gt; blastX(db, query [, limit] [, noCache], outfmt) search nucleotide on protein database. search nucleotide on protein database Parameters: Name Type Argument Default Description db query string the sequence piece limit string &lt;optional&gt; noCache boolean &lt;optional&gt; outfmt string 0 Source: lib/blastjs.js, line 103 Returns: Type Promise.&lt;*&gt; &lt;static&gt; tblastN(db, query [, limit] [, noCache], outfmt) search protein on nucleotide database. search protein on nucleotide database Parameters: Name Type Argument Default Description db query string the sequence piece limit string &lt;optional&gt; noCache boolean &lt;optional&gt; outfmt string 0 Source: lib/blastjs.js, line 116 Returns: Type Promise.&lt;*&gt; &lt;static&gt; tblastX(db, query [, limit] [, noCache], outfmt) tblaspx The tblastx application searches a translated nucleotide query against translated nucleotide subject sequences or a translated nucleotide database. Parameters: Name Type Argument Default Description db query string the sequence piece limit string &lt;optional&gt; noCache boolean &lt;optional&gt; outfmt string 0 Source: lib/blastjs.js, line 130 Returns: Type Promise.&lt;*&gt; × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
